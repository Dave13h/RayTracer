// ___  ___      _        _
// |  \/  |     | |      (_)
// | .  . | __ _| |_ _ __ ___  __
// | |\/| |/ _` | __| '__| \ \/ /
// | |  | | (_| | |_| |  | |>  <
// \_|  |_/\__,_|\__|_|  |_/_/\_\
// 								  Class


#include "matrix.h"

// -------------------------------------------------------------------------------------------------
// Constructors
// -------------------------------------------------------------------------------------------------
mat4::mat4(void) {
	m[0][0] = 1.0f;
	m[0][1] = 0.0f;
	m[0][2] = 0.0f;
	m[0][3] = 0.0f;

	m[1][0] = 0.0f;
	m[1][1] = 1.0f;
	m[1][2] = 0.0f;
	m[1][3] = 0.0f;

	m[2][0] = 0.0f;
	m[2][1] = 0.0f;
	m[2][2] = 1.0f;
	m[2][3] = 0.0f;

	m[3][0] = 0.0f;
	m[3][1] = 0.0f;
	m[3][2] = 0.0f;
	m[3][3] = 1.0f;
}

mat4::mat4(const float in[4][4]) {
	m[0][0] = in[0][0];
	m[0][1] = in[0][1];
	m[0][2] = in[0][2];
	m[0][3] = in[0][3];

	m[1][0] = in[1][0];
	m[1][1] = in[1][1];
	m[1][2] = in[1][2];
	m[1][3] = in[1][3];

	m[2][0] = in[2][0];
	m[2][1] = in[2][1];
	m[2][2] = in[2][2];
	m[2][3] = in[2][3];

	m[3][0] = in[3][0];
	m[3][1] = in[3][1];
	m[3][2] = in[3][2];
	m[3][3] = in[3][3];
}

mat4::mat4(const quat4 in) {
	float x2 = in.x + in.x;
	float y2 = in.y + in.y;
	float z2 = in.z + in.z;

	float xx = in.x * x2;
	float yx = in.y * x2;
	float yy = in.y * y2;
	float zx = in.z * x2;
	float zy = in.z * y2;
	float zz = in.z * z2;
	float wx = in.w * x2;
	float wy = in.w * y2;
	float wz = in.w * z2;

	m[0][0] = 1.0f - yy - zz;
	m[0][1] = yx + wz;
	m[0][2] = zx - wy;
	m[0][3] = 0.0f;

	m[1][0] = yx - wz;
	m[1][1] = 1.0f - xx - zz;
	m[1][2] = zy + wx;
	m[1][3] = 0.0f;

	m[2][0] = zx + wy;
	m[2][1] = zy - wx;
	m[2][2] = 1.0f - xx - yy;
	m[2][3] = 0.0f;

	m[3][0] = 0.0f;
	m[3][1] = 0.0f;
	m[3][2] = 0.0f;
	m[3][3] = 1.0f;
}

// -------------------------------------------------------------------------------------------------
// Operators
// -------------------------------------------------------------------------------------------------
mat4 mat4::operator*(const mat4 in) {
	mat4 n;
	for (int i = 0; i < 4; ++i) {
		for (int j = 0; j < 4; ++j) {
			n.m[i][j] =
				m[i][0] * in.m[0][j] +
				m[i][1] * in.m[1][j] +
				m[i][2] * in.m[2][j] +
				m[i][3] * in.m[3][j];
		}
	}
	return n;
}

vec3 mat4::operator*(const vec3 in) {
	vec3 v;
	v.x = in.x * m[0][0] + in.y * m[1][0] + in.z * m[2][0];
	v.y = in.x * m[0][1] + in.y * m[1][1] + in.z * m[2][1];
	v.z = in.x * m[0][2] + in.y * m[1][2] + in.z * m[2][2];
	return v;
}

// -------------------------------------------------------------------------------------------------
// Methods
// -------------------------------------------------------------------------------------------------
void mat4::scale(const float s) {
	m[0][0] *= s;
	m[0][1] *= s;
	m[0][2] *= s;
	m[0][3] *= s;

	m[1][0] *= s;
	m[1][1] *= s;
	m[1][2] *= s;
	m[1][3] *= s;

	m[2][0] *= s;
	m[2][1] *= s;
	m[2][2] *= s;
	m[2][3] *= s;
}
void mat4::scale(const vec3 s) {
	m[0][0] *= s.x;
	m[0][1] *= s.x;
	m[0][2] *= s.x;
	m[0][3] *= s.x;

	m[1][0] *= s.y;
	m[1][1] *= s.y;
	m[1][2] *= s.y;
	m[1][3] *= s.y;

	m[2][0] *= s.z;
	m[2][1] *= s.z;
	m[2][2] *= s.z;
	m[2][3] *= s.z;
}
